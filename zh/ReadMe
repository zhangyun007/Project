有好的想法、意见，请Email：zhaoyun004@qq.com


Zh是一套程序设计系统。核心是一个程序解释器，用于解释用户编写的各种程序。为了编写程序，用户只需要一个能很漂亮显示程序的文本编辑软件，推荐使用开源、免费软件：Notepad++、Sublime Text。

用户获得软件是非常容易的，但是获得正确的编程知识确很难。众多的程序设计系统，可能让人眼花缭乱，抓不住重点。

本套程序设计系统目的在于，让用户尽可能简单的编程。理想情况下，一开始，你能所做的事情很少。但是，随着你编写的程序越来越多，程序设计的基本元素都已经掌握，也编写了一堆函数库、熟悉了各种数据结构和算法。你对这个系统越来越得心应手，甚至不想离开她。


一、系统需求：Python3


二、下载源代码、运行测试

git clone https://github.com/zhangyun007/Zh.git

运行python Zh.py进入单行交互模式。

运行python Zh.py test.s解释执行test.s文件，测试文件包括：scheme.s test.s new.s first.s newton.s

扩展名为ss的文件可以运行在Racket和ChezScheme下，而不能运行在ZhScheme中。



三、下载Windows可执行文件

我们使用pyinstaller模块生成来了Windows下的exe文件，用户可以直接运行zh.exe进入单行交互模式，或者使用zh.exe test.s解释执行某个文件。



四、文本编辑环境

Windows系统下，推荐使用Notepad++，在菜单栏语言选项里选择Lisp，会将部分关键词彩色显示。注意，不能选择Scheme，选择Scheme，只有黑白显示文本。

其次是Sublime Text3。ST虽然很好，但是对于中文支持总是需要你做一些额外的任务，这种任务是枯燥的，为什么不配置好，下载就能支持UTF-8呢。多次折腾之后，我厌倦了自己去下载插件支持UTF-8。于是，我回头用上了Notepad++。


五、

该程序设计系统的基本数据类型和数据结构和Python完全一样。虽然很像Lisp、Scheme，但是不符合任何一个Lisp，Scheme标准，作者无意实现一个符合某个标准的Scheme或者Lisp。


待完善功能：  
import直接执行http；函数多个参数；递归函数调用层次太少; class，thread


单行交互模式

运行python Zh.py，进入单行交互模式。按照惯例，打印hello world:
(print "hello , world!")
print是Python内置函数，可以直接使用。

 计算3+4:
 (+ 3 4)或者3+4

运行(env g)查看内置变量和函数，这些函数和变量可以直接使用：
E:\Project\Zh>python Zh.py
Zh> (env g)
['env']
env ...
+  :  <built-in function add>
-  :  <built-in function sub>
*  :  <built-in function mul>
/  :  <built-in function truediv>
>  :  <built-in function gt>
<  :  <built-in function lt>
>=  :  <built-in function ge>
<=  :  <built-in function le>
=  :  <built-in function eq>
not  :  <function <lambda> at 0x0000000002C2ABF8>
eq?  :  <built-in function is_>
equal?  :  <built-in function eq>
max  :  <built-in function max>
min  :  <built-in function min>
abs  :  <built-in function abs>
round  :  <built-in function round>
tuple  :  <function <lambda> at 0x0000000002C2A510>
dict  :  <function <lambda> at 0x0000000002C2A598>
car  :  <function <lambda> at 0x0000000002C2A620>
cdr  :  <function <lambda> at 0x0000000002C2A6A8>
list  :  <function <lambda> at 0x0000000002C2A730>
|  :  <function <lambda> at 0x0000000002C2A7B8>
append  :  <built-in function add>
len  :  <built-in function len>
map  :  <class 'map'>
print  :  <built-in function print>
exit  :  Use exit() or Ctrl-Z plus Return to exit
open  :  <built-in function open>
procedure?  :  <built-in function callable>
null?  :  <function <lambda> at 0x0000000002C2A840>
bool?  :  <function <lambda> at 0x0000000002C2A8C8>
number?  :  <function <lambda> at 0x0000000002C2A950>
string?  :  <function <lambda> at 0x0000000002C2A9D8>
tuple?  :  <function <lambda> at 0x0000000002C2AA60>
list?  :  <function <lambda> at 0x0000000002C2AAE8>
dict?  :  <function <lambda> at 0x0000000002C2AB70>
and  :  <function <lambda> at 0x0000000002C2AC80>
or  :  <function <lambda> at 0x0000000002C2AD08>
isa  :  <built-in function isinstance>
dir  :  <built-in function dir>
type  :  <class 'type'>
getattr  :  <built-in function getattr>
setattr  :  <built-in function setattr>
.  :  <function <lambda> at 0x0000000002C2AD90>
int  :  {}
__name__  :  math
__doc__  :  This module is always available.  It provides access to the
mathematical functions defined by the C standard.
__package__  :
__loader__  :  <class '_frozen_importlib.BuiltinImporter'>
__spec__  :  ModuleSpec(name='math', loader=<class '_frozen_importlib.BuiltinImp
orter'>, origin='built-in')
acos  :  <built-in function acos>
acosh  :  <built-in function acosh>
asin  :  <built-in function asin>
asinh  :  <built-in function asinh>
atan  :  <built-in function atan>
atan2  :  <built-in function atan2>
atanh  :  <built-in function atanh>
ceil  :  <built-in function ceil>
copysign  :  <built-in function copysign>
cos  :  <built-in function cos>
cosh  :  <built-in function cosh>
degrees  :  <built-in function degrees>
erf  :  <built-in function erf>
erfc  :  <built-in function erfc>
exp  :  <built-in function exp>
expm1  :  <built-in function expm1>
fabs  :  <built-in function fabs>
factorial  :  <built-in function factorial>
floor  :  <built-in function floor>
fmod  :  <built-in function fmod>
frexp  :  <built-in function frexp>
fsum  :  <built-in function fsum>
gamma  :  <built-in function gamma>
gcd  :  <built-in function gcd>
hypot  :  <built-in function hypot>
isclose  :  <built-in function isclose>
isfinite  :  <built-in function isfinite>
isinf  :  <built-in function isinf>
isnan  :  <built-in function isnan>
ldexp  :  <built-in function ldexp>
lgamma  :  <built-in function lgamma>
log  :  <built-in function log>
log1p  :  <built-in function log1p>
log10  :  <built-in function log10>
log2  :  <built-in function log2>
modf  :  <built-in function modf>
pow  :  <built-in function pow>
radians  :  <built-in function radians>
sin  :  <built-in function sin>
sinh  :  <built-in function sinh>
sqrt  :  <built-in function sqrt>
tan  :  <built-in function tan>
tanh  :  <built-in function tanh>
trunc  :  <built-in function trunc>
pi  :  3.141592653589793
e  :  2.718281828459045
tau  :  6.283185307179586
inf  :  inf
nan  :  nan
....
Zh>(exit)

用户可在程序的任何位置调用(env)查看当前块的环境，改关键字用于调试程序，有时候可能比手工打印更方便，毕竟(env)一次打印当前块的所有变量值。

注意：打印出的变量值是一个Python列表：["abc" 1]，第一项是变量值，第二项表示变量是否使用，1意为已经使用过，0表示未使用。


数据类型：

一、基本数据类型(和Python保持一致)：
int float bool string 

二、复合数据类型(和Python保持一致)：

定义一个元组: 
(set a (tuple 12 34))

定义一个列表: 
(set a (list 12 34))，简写: (set a (' 12 34))

列表元素访问
(set (i (list 12 "hello" 34 True)))
简写：(set (i (' 12 "hello" 34 True)))

(| i 2)      -- 获得i的第二项 34
i|2         -- 意义同上。

列表元素访问操作符为|，不同于大多程序设计系统使用[]访问数组或者列表，我们使用操作符|访问列表元素。用户少敲一个字符，同时解释器的实现也少写一些代码。 


定义一个字典: 
(set (d (dict (' (' "+" +) 
    (' "-" -)
    (' "*" *)
    (' "/" /)
    )))
)

字典元素访问：


中缀表达式：

支持符号中缀表达式：j|3.n+3*2-1。符号的运算从左到右。该表达式+在*左边，所以先算+，后算*，这和数学中定义的运算符优先级是不一致的 --- 3+4*2的结果为14。

注意:

一、表达式中不能有空格，否则会当成几个由空格隔开的表达式，这和其他多数程序设计系统是不一样的。

二、多数Scheme使用-作为变量分隔符，比如你可以定义一个变量is-a-list，而我们系统支持中缀表达式，-的意义是算术中的减号，is-a-list的意义是是3个变量相减。你应当使用_来分割字符串作为变量名:is_a_list。


中缀和前缀的混合使用：j|3.n+(* 3 2)-1 (未完成)

多数（标准）Scheme里，变量需要先define(定义)，然后set!(赋值)，其实，定义和赋值用一个关键字更好。我们使用set直接定义并赋值，而且一次能定义并赋值多个变量：

(set (a 12) (b 13) (c "hello"))



顺序块 (begin (...) (...) (...))
begin -- 关键字，将依次计算各项；可以嵌套使用。

条件块 (if (1) (2) (3)) 
if -- 关键字，判断1的结果，如果为True，则计算2，否则计算3，23项必须有，可以为();可以嵌套使用。

循环块 -- 可以嵌套使用
while, for, break

each


函数定义define与lambda

多数程序设计系统提供return语句，函数有返回值，zh系统函数没有返回值，我们建议使用函数外层的一个变量作为返回值。例如：
(set (s 0))
(define (sum a b) ( set (s (+ a b))))
(sum 3 4)
以上，变量s可以在sum函数内部访问到，充当sum的返回值。

函数内部可以定义函数，参见newton.s，函数A内定义的函数只能在函数A内使用，A外部的其他函数不能使用。


函数调用

函数调用时实参个数不一定要和形参个数一样。

几乎所有的程序设计系统中，函数的调用都是通过名为"栈"(stack)的数据结构，通常，栈空间是连续的。如果用C程序来实现一个栈，最简单的方式是定义一个字符数组：

char s[1024]；

这样，你可以用s这个字符数组才存储函数参数、变量以及返回值。

不过，在我们的程序设计系统中，函数调用形成的并不是栈结构，而是树结构。


class

程序设计者可以使用Python的type函数创建一个类，但是多数情况下，你应该使用class直接定义一个类，使用.操作符访问对象的成员。尽量避免使用type函数，因为type太低层，除非你想自己实现一套面向对象程序设计系统，可以参考type的函数参数和返回值设计。

(class point (
    (set n 12)
    (define fun (lambda x (* 2 x)))
))

读写文件

读写文件直接使用Python的file对象，以下程序打开test.ss文件，并读取，打印：
(set (f (open "test.ss" "r")))
(print (f.read))


其他常用特性：


并行单元

每个并行单元是一段在一个CPU核心上运行的代码。一个并行单元内的代码是不可能被分配到两个不同的CPU核心上执行的;而不同的并行单元，可能会在同一个CPU核心上执行 -- 线程切换，或者一个并行单元完成后，执行另一个并行单元；在多核CPU计算机上，通常会放在不同的CPU上执行，互不影响。

常规计算和的代码：

    (define (sum x r)
      (if (eq? x 0)
          (print r)
          (sum (- x 1) (+ x r))
       )
    )
    (sum 400 0)

并行后的代码：

(define (sum x y z )
    (if (eq? x y)
        z
        (sum (- x 1) y (+ x r))
     )
)


(thread  s1
    (begin
        (set (s1 0))
        (set (s1 (sum 1000 500 0)))
    )
)

(thread  s2
    (begin
        (set (s2 0))
        (set (s2 (sum 500 0 0)))
    )
)

#这里要等上面两个thread的s1 s2的计算完成后才可计算。
(set (s3 (+ s1 s2)))
(print s3)

一、运行时间 (time (..))  

time --- 关键字，time后只能有一项参数，运行参数项，并打印运行时间。
例如：(time (+ 4 5)) --- 计算”4+5“，并打印运行时间。

你可以用begin将一系列语句包装起来，作为time的参数:
(time (begin (...) (...) (...) (...)))

嵌套使用：
(time (begin (...) (time (...)) (...) (...)))


二、单元测试

单元测试，也就是编写代码测试你的函数。编写单元测试代码，可以避免枯燥重复的手工调试，是良好的编程习惯。

一个运行次数很少、非常简单、几乎不会出错的函数，不需要单元测试；函数越复杂， 输入和输出(参数和返回值)的逻辑关系越复杂，改动越频繁，越需要单元测试。

(expect (sum 100 0) 5050)

expect关键字运算第二个参数（预期是一个函数调用），如果其结果和第三个参数不符，则打印出错误信息。

我们定义一个函数：
(define (expect x y) (if (!= (x) y)
    (print "Not Expect!")
))


三、无用变量的检测警告功能：

new.s文件中定义了一个没有被使用的变量和函数，解释器能够检测到，并给出警告：
(set (abc 123))
(define (efg x) (x))

python Zh.py new.s

E:\Project\Zh>python Zh.py new.s
45150
0
0:00:00.012001
Warn : [ abc ] is not used.
Warn : [ efg ] is not used.


四、递归函数和尾递归

  (define (sum x r)
      (if (eq? x 0)
          (print r)
          (sum (- x 1) (+ x r))
       )
    )
   (sum 150 0)
   
如果一个函数定义内调用了自身，那么该函数是一个递归函数。一个函数是否递归函数和该函数是否被真正调用无关，当程序设计者编写完成一个能按自己预期函数时，该函数是否递归就已经被决定了。

这段话似乎很显然，但是当我们编程时，会忘记这些显然的道理。要做尾递归优化，你必须先判断该函数是一个递归函数，而且被尾调用了 --- 你必须检测函数定义判断该函数是否递归，而不是根据最终的函数调用来判断。

一个递归函数，可能只调用了一次结束递归了，虽然该函数没有被递归调用，但是，该函数仍然是一个递归函数。比如上述sum函数，如果你调用(sum 0 0)，sum其实只被调用了一次就结束了。但是，Sum仍然是一个递归函数。


确定是尾递归后，程序中，我们不用新创建env对象，继续使用上一层env对象即可。


五、中文编程

Zh支持使用中文作为过程名（函数名）。对于中文编程，已经有人作出一些尝试，如易语言中文编程、文言文编程，都有人尝试。

电子计算机诞生于美国，最先支持的是英文字母，中文等其他国家的文字的支持比较流行的方案是UTF8，早期还有GBK中文编码等方案。

我的看法是，简单的英语并不难学，特别是程序设计的关键字，也许初中甚至小学生都能掌握，但是庞大的函数库，就难说了，甚至专业顶级的程序设计师都不可能掌握所有的库。一门程序设计系统，可能会有千万种库，这些库通常都是英文函数名、类名、变量名、甚至文档都是英文的。

我希望程序设计者，适当的使用中文编程：把你的过程名称换成人们一看就懂的中文过程名，也许你基本不用写注释了。我希望使用中文的程序设计师们，不要害怕、抵制建立一个庞大的中文程序库。至少，你应该有这种想象。缺乏了这种想象，甚至抵制这种想象，是非常糟糕的。

下面是一个简单的例子：

(define (两数相加 x y) (+ x y))
(两数相加 3 4)

以上程序，得到结果7。

倘若你文言文学得好，用文言文命名过程名也是可以的。


和Lisp/Scheme的一些区别（不完全）：


一、; quote用于注释。

取消了Symbol类型，使用python字符串。

二、define和set!

ZhScheme中，define只能定义函数，而变量直接用set定义并赋值，set可以一次定义/赋值多个变量。

三、bool类型

Scheme里bool值为#T和#F,ZheScheme直接使用Python的bool型 -- True和False

四、实现了C风格的while，for循环，循环体中可以使用break跳出循环。

五、取消了cons，实现了car和cdr

Scheme中的cons，作用是构造一个pair，包括左右两个值，在ChezScheme和Racket中，(cons 1 2)的输出是(1 . 2)，用.来区分左右两部分，car取得左值，cdr取得右值，可以对一个list取car和cdr。

六、(env)查看当前的环境变量，你可以在任意位置调用

七、(import test.s)导入并执行test.s文件，可以在任意位置调用。

八、取消了call/cc。笔者认为call/cc相对循环和break语句，更难掌握，因此删掉了call/cc相关代码，增加了break关键字 -- 跳出循环。

九、中缀表达式：
