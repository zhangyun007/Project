系统需求：Python3

运行python ZhScheme.py进入单行交互模式。

运行python ZhScheme.py test.s解释执行test.s文件。

scheme.s test.s new.s为测试文件

https://segmentfault.com/q/1010000022586274


待完善功能：call/cc 递归函数调用层次太少... 生成Lua虚拟机字节码
 

ZhScheme大量使用Python内置函数，数据结构和Python完全一样 --- 只是形式上学习了Lisp/Scheme -- 成对的()。

ZhScheme不符合任何一个Lisp，Scheme标准。作者无意实现一个符合某个标准的Scheme或者Lisp。ZhScheme更像Python，因为笔者学习使用Python的时间更多，Scheme中List正好对应Python的List，用Python List来实现Scheme List非常容易。


和Lisp/Scheme的区别：

一、取消了cons，实现了car和cdr

Scheme中的cons，作用是构造一个pair，包括左右两个值，在ChezScheme和Racket中，(cons 1 2)的输出是(1 . 2)，用.来区分左右两部分，car取得左值，cdr取得右值，可以对一个list取car和cdr。

二、quote，用于注释。

取消了Symbol类型，使用python字符串。

三、define和set!

ZhScheme中，define只能定义函数，而变量直接用set定义并赋值。

四、bool类型

Scheme里bool值为#T和#F,ZheScheme直接使用Python的bool型 -- True和False



单行交互模式

运行python ZhScheme.py，进入单行交互模式。按照惯例，打印hello world:

(print "hello , world!")

print是Python内置函数，可以直接使用。


我们复习一下Python的数据类型，并学习使用set为一个变量赋值。

一、基本数据类型(和Python保持一致)：
int float bool string 

二、复合数据类型(和Python保持一致)：
list tuple dict


时间 (time (..))  
time --- 关键字，time后只能有一项参数，运行参数项，并打印出其运行时间。有时候，你需用分析程序的性能瓶颈，哪个函数花了太多时间？你需要一个简单的方法来作这项工作。 

例如：(time (+ 4 5)) --- 计算”4+5“，并打印其运行时间。

你可以将任意长度和深度的块放在time后面，只需要用begin包起来即可：

(time (begin (...) (...) (...) (...)))

可以嵌套使用：

(time (begin (...) (time (...)) (...) (...)))

顺序 (begin (...) (...) (...))
begin -- 关键字，将依次计算各项，返回最后一项的结果。
可以嵌套使用。

条件 (if (1) (2) (3)) 
if -- 关键字，判断1的结果，如果为True，则计算2并返回，否则计算3并返。
可以嵌套使用。

循环
while, for, for-each

break, continue 


函数与lambda


内置函数：

内置函数一部分直接使用了Python内置函数，或者是某个python模块定义的函数，还有一部分是简单的lambda函数，我们编写Scheme程序时可以直接使用这些内置函数。


Class

程序设计者可以使用Python的type函数创建一个类，但是多数情况下，你应该使用class直接定义一个类，(. object m)访问类的成员，尽量避免使用type函数。


其他特性：

一、无用变量的检测警告功能：

new.s文件中定义了一个没有被使用的变量和函数，解释器能够检测到，并给出警告：
(set abc 123)
(set (efg  x) (x))

python ZhScheme.py new.s

E:\Project\ZhScheme>python ZhScheme.py new.s
45150
0
0:00:00.012001
Warn : [ abc ] is not used.
Warn : [ efg ] is not used.

call/cc


递归函数和尾递归

  (set sum 0)
  (define (sum x r)
      (if (eq? x 0)
          r
          (sum (- x 1) (+ x r))
       )
    )
   (sum 150 0)

当使用以上求和递归时，超过200层就会出现错误提示:栈不够用。

  
当人们学习Scheme程序时，可能印象最深的是对称的()。我们欣赏这种对称，也许我们会想当然的认为这种对称的语法，方便作文法分析 -- 也许实际并不是这样。

作文法分析时，我们似乎总是不可避免的要写一个递归函数，去读取或者分析你的程序文本。这个递归函数比我们初学的求和、数列递归难太多。当语法很简单时，可能还能理解可以修修改改，增加一些功能；随着语法的复杂，功能的增加，这个递归函数越来越复杂，以至于人们不能顺利理解，更谈不上修改增加一些功能，而那些对此游刃有余的同学，可以称为编译专家了。

以笔者粗浅的理解，编译技术的难点在于这个及其复杂的递归函数，层层调用，一环套一环，容易让读者”迷路“，从而丧失耐心和信心。

求和、数列等递归程序实际上可以用循环代替 --  循环语句更容易理解，而且不会出现递归调用层数太多导致栈不够用的情况 --为什么要自找麻烦写递归呢？但是，编译技术中的递归函数，似乎无法用循环代替 -- 笔者不敢确定.