系统需求：Python3

运行python ZhScheme.py进入单行交互模式。

运行python ZhScheme.py test.s解释执行test.s文件。

scheme.s test.s new.s为测试文件



ZhScheme大量使用Python内置函数，数据结构和Python完全一样 --- 只是形式上学习了Lisp/Scheme -- 成对的()。

ZhScheme不符合任何一个Lisp，Scheme标准。作者无意实现一个符合某个标准的Scheme或者Lisp，而是使用各种容易理解、好用、常用的程序设计元素。

ZhScheme更像Python，因为笔者学习使用Python的时间更多，而Scheme中数据结构List正好对应Python的List，用Python List来实现Scheme List非常容易。



Scheme中的cons，作用是构造一个pair，包括左右两个值，在ChezScheme和Racket中，(cons 1 2)的输出是(1 . 2)，显然，他们用.来区分左右两部分。car取得左值，cdr取得右值。

笔者深究cons，用稍显复杂的逻辑来测试list和cons，发现其中有难以自圆其说的地方。也许，这是笔者的一些强迫症，不过，我们完全可以把python list当作cons，你只要把list的第一项当作左值，后面所有的项当作右值。在Python里，car和cdr其实就是一个list的x[0]和x[1:]。

既然cons可能会导致复杂、概念上的混乱，与其强行费劲解释这稍显复杂的”设计“，不如简单的抛弃不用。笔者甚至抛弃了Scheme中的符号类型(Symbol)，而简单代替以字符串类型。



quote，程序注释。

car和cdr，返回一个List的第一项和剩余项。

set!赋值改为set



递归浅谈


当人们学习Scheme程序时，可能印象最深的是对称的()。我们欣赏这种对称，也许我们会想当然的认为这种对称的语法，方便作文法分析 -- 也许实际并不是这样。

作文法分析时，我们似乎总是不可避免的要写一个递归函数，去读取或者分析你的程序文本。这个递归函数比我们初学的求和、数列递归难太多。当语法很简单时，可能还能理解可以修修改改，增加一些功能；随着语法的复杂，功能的增加，这个递归函数越来越复杂，以至于人们不能顺利理解，更谈不上修改增加一些功能，而那些对此游刃有余的同学，可以称为编译专家了。

以笔者粗浅的理解，编译技术的难点在于这个及其复杂的递归函数，层层调用，一环套一环，容易让读者”迷路“，从而丧失耐心和信心。

求和、数列等递归程序实际上可以用循环代替 --  循环语句更容易理解，而且不会出现递归调用层数太多导致栈不够用的情况 --为什么要自找麻烦写递归呢？但是，编译技术中的递归函数，似乎无法用循环代替 -- 笔者不敢确定。如果将来有人发明这种方法，也许会让编译技术更加容易。



单行交互模式

运行python ZhScheme.py，进入单行交互模式。按照惯例，打印hello world:

(print "hello , world!")

print是Python内置函数，可以直接使用。


我们复习一下Python的数据类型，并学习使用define关键字定义一个变量，使用set关键字为一个变量赋值。

一、基本数据类型(和Python保持一致)：
int float bool string 

二、复合数据类型(和Python保持一致)：
list tuple dict


三、程序块(block)：我们把一对（）中间的程序，称为"块"(block)。一个block里可以有0个或者多个block。每个块里定义的变量和函数只在当前块内部可见，外部块不可见。


时间 (time (..))  
time --- 关键字，time后只能有一项参数，运行参数项，并打印出其运行时间。有时候，你需用分析程序的性能瓶颈，哪个函数花了太多时间？你需要一个简单的方法来作这项工作。 

例如：(time (+ 4 5)) --- 计算”4+5“，并打印其运行时间。

你可以将任意长度和深度的块放在time后面，只需要用begin包起来即可：

(time (begin (...) (...) (...) (...)))

可以嵌套使用：

(time (begin (...) (time (...)) (...) (...)))


顺序 (begin (...) (...) (...))
begin -- 关键字，将依次计算各项，返回最后一项的结果。
可以嵌套使用。

条件 (if (1) (2) (3)) 
if -- 关键字，判断1的结果，如果为True，则计算2并返回，否则计算3并返。
可以嵌套使用。

循环
while, for, for-each

break, continue 


函数与lambda


内置函数：

内置函数一部分直接使用了Python内置函数，或者是某个python模块定义的函数，还有一部分是简单的lambda函数，我们编写Scheme程序时可以直接使用这些内置函数。

结构体(Class)

call/cc

递归函数和尾递归



其他特性：

一、无用变量的检测警告功能：

new.s文件中定义了一个没有被使用的变量和函数，解释器能够检测到，并给出警告：
(define abc 123)
(define (efg  x) (x))

python ZhScheme.py new.s

E:\Project\ZhScheme>python ZhScheme.py new.s
45150
0
0:00:00.012001
Warn : [ abc ] is not used.
Warn : [ efg ] is not used.



