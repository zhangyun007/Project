scheme.s test.s new.s测试文件

运行python ZhScheme.py test.s解释执行test.s文件。

或者python ZhScheme.py进入单行交互模式。

系统需求：Python3


ZhScheme不符合任何一个Lisp，Scheme标准。作者无意实现一个符合某个标准的Scheme或者Lisp，只是按照自己也许有点独特的编程习惯，加入那些自认为容易理解、常用、好用的程序设计元素。

ZhScheme更像Python，因为笔者学习使用Python的时间更多，而Scheme中唯一的数据结构List正好对应与Python的List，用Python List来实现Scheme List非常容易。


当人们学习Scheme程序时，可能印象最深的是对称的()，不探究实质，我们欣赏这种对称美，也许我们会想当然的认为这种对称的语法，方便作文本和语义分析 -- 虽然实际上也许并不是这样。

作语法分析时，我们似乎总是不可避免的要写一个递归函数，去读取或者分析你的程序文本。这个递归函数比我们初学的求和、数列递归难太多。当语法很简单时，可能还能理解可以修修改改，增加一些功能；随着语法的复杂，功能的增加，这个递归函数越来越复杂，以至于人们不能顺利理解，更谈不上修改增加一些功能，而那些对此游刃有余的同学，可以称为编译专家了。

以笔者粗浅的理解，编译技术的难点在于这个及其复杂的递归函数，层层调用，一环套一环，容易让读者”迷路“，从而丧失信心。


求和、数列等递归程序实际上可以用循环代替 --  循环语句更容易理解，而且不会出现递归调用层数太多导致栈不够用的情况 --为什么要自找麻烦写递归呢？但是，编译技术中的递归函数，似乎无法用循环代替 -- 笔者不敢确定。如果将来有人发明这种方法，也许会让编译技术更加容易。

C程序中有go关键字，但是被计算机科学家批评go语句会打乱程序流程，让人糊涂 --- 大量的使用go可能会出现这种情况-- 但是难道复杂的递归就不会让人糊涂吗？ 笔者已经无数次被编译技术中的递归函数给难倒..


ZhScheme大量使用Python内置函数，数据结构和Python完全一样 --- 只是形式上学习了Lisp/Scheme -- 成对的()。



单行交互模式

运行python ZhScheme.py，进入单行交互模式。

在这个模式下，我们复习一下Python的数据类型，并学习使用define关键字定义一个变量，使用set关键字为一个变量赋值。

一、基本数据类型(和Python保持一致)：
int float bool string 

二、复合数据类型(和Python保持一致)：
list tuple dict


三、程序块(block)：我们把一对（）中间的程序，称为"块"(block)。一个block里可以有0个或者多个block。每个块里定义的变量和函数只在当前块内部可见，外部块不可见。

时间 (time (..))  
time --- 关键字，time后只能有一项参数。

顺序 (begin (...) (...) (...))
begin -- 关键字，将依次计算各项，返回最后一项的结果。

条件 (if (1) (2) (3))
if -- 关键字，将判断1的结果，如果为True，则计算2并返回，否则计算3并返回，

循环
while, for, break, continue


函数与lambda


内置函数：

内置函数一部分直接使用了Python内置函数，或者是某个python模块定义的函数，还有一部分是简单的lambda函数，我们编写Scheme程序时可以直接使用这些内置函数。

结构体(Class)

call/cc

递归函数和尾递归



其他特性：

一、无用变量的检测警告功能：

new.s文件中定义了一个没有被使用的变量和函数，解释器能够检测到，并给出警告：
(define abc 123)
(define (efg  x) (x))

python ZhScheme.py new.s

E:\Project\ZhScheme>python ZhScheme.py new.s
45150
0
0:00:00.012001
Warn : [ abc ] is not used.
Warn : [ efg ] is not used.



