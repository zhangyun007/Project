一、系统需求：Python3


二、下载代码、运行测试

git clone https://github.com/zhangyun007/ZhScheme.git

运行python ZhScheme.py进入单行交互模式。

运行python ZhScheme.py test.s解释执行test.s文件，测试文件包括：scheme.s test.s new.s first.s newton.s

扩展名为ss的文件可以运行在Racket和ChezScheme下，而不能运行在ZhScheme中。



ZhScheme不符合任何一个Lisp，Scheme标准，作者无意实现一个符合某个标准的Scheme或者Lisp。ZhScheme更像Python，大量使用Python内置函数，数据类型和结构和Python完全一样。


待完善功能：  
import直接执行http；函数多个参数；递归函数调用层次太少；生成Lua虚拟机字节码


单行交互模式

运行python ZhScheme.py，进入单行交互模式。按照惯例，打印hello world:
(print "hello , world!")
print是Python内置函数，可以直接使用。

 计算3+4:
 (+ 3 4)或者3+4

运行(env)查看内置变量和函数，这些函数和变量可以直接使用：
E:\Project\ZhScheme>python ZhScheme.py
ZhScheme> (env)
['env']
env ...
+  :  <built-in function add>
-  :  <built-in function sub>
*  :  <built-in function mul>
/  :  <built-in function truediv>
>  :  <built-in function gt>
<  :  <built-in function lt>
>=  :  <built-in function ge>
<=  :  <built-in function le>
=  :  <built-in function eq>
not  :  <function <lambda> at 0x0000000002C2ABF8>
eq?  :  <built-in function is_>
equal?  :  <built-in function eq>
max  :  <built-in function max>
min  :  <built-in function min>
abs  :  <built-in function abs>
round  :  <built-in function round>
tuple  :  <function <lambda> at 0x0000000002C2A510>
dict  :  <function <lambda> at 0x0000000002C2A598>
car  :  <function <lambda> at 0x0000000002C2A620>
cdr  :  <function <lambda> at 0x0000000002C2A6A8>
list  :  <function <lambda> at 0x0000000002C2A730>
|  :  <function <lambda> at 0x0000000002C2A7B8>
append  :  <built-in function add>
len  :  <built-in function len>
map  :  <class 'map'>
print  :  <built-in function print>
exit  :  Use exit() or Ctrl-Z plus Return to exit
open  :  <built-in function open>
procedure?  :  <built-in function callable>
null?  :  <function <lambda> at 0x0000000002C2A840>
bool?  :  <function <lambda> at 0x0000000002C2A8C8>
number?  :  <function <lambda> at 0x0000000002C2A950>
string?  :  <function <lambda> at 0x0000000002C2A9D8>
tuple?  :  <function <lambda> at 0x0000000002C2AA60>
list?  :  <function <lambda> at 0x0000000002C2AAE8>
dict?  :  <function <lambda> at 0x0000000002C2AB70>
and  :  <function <lambda> at 0x0000000002C2AC80>
or  :  <function <lambda> at 0x0000000002C2AD08>
isa  :  <built-in function isinstance>
dir  :  <built-in function dir>
type  :  <class 'type'>
getattr  :  <built-in function getattr>
setattr  :  <built-in function setattr>
.  :  <function <lambda> at 0x0000000002C2AD90>
int  :  {}
__name__  :  math
__doc__  :  This module is always available.  It provides access to the
mathematical functions defined by the C standard.
__package__  :
__loader__  :  <class '_frozen_importlib.BuiltinImporter'>
__spec__  :  ModuleSpec(name='math', loader=<class '_frozen_importlib.BuiltinImp
orter'>, origin='built-in')
acos  :  <built-in function acos>
acosh  :  <built-in function acosh>
asin  :  <built-in function asin>
asinh  :  <built-in function asinh>
atan  :  <built-in function atan>
atan2  :  <built-in function atan2>
atanh  :  <built-in function atanh>
ceil  :  <built-in function ceil>
copysign  :  <built-in function copysign>
cos  :  <built-in function cos>
cosh  :  <built-in function cosh>
degrees  :  <built-in function degrees>
erf  :  <built-in function erf>
erfc  :  <built-in function erfc>
exp  :  <built-in function exp>
expm1  :  <built-in function expm1>
fabs  :  <built-in function fabs>
factorial  :  <built-in function factorial>
floor  :  <built-in function floor>
fmod  :  <built-in function fmod>
frexp  :  <built-in function frexp>
fsum  :  <built-in function fsum>
gamma  :  <built-in function gamma>
gcd  :  <built-in function gcd>
hypot  :  <built-in function hypot>
isclose  :  <built-in function isclose>
isfinite  :  <built-in function isfinite>
isinf  :  <built-in function isinf>
isnan  :  <built-in function isnan>
ldexp  :  <built-in function ldexp>
lgamma  :  <built-in function lgamma>
log  :  <built-in function log>
log1p  :  <built-in function log1p>
log10  :  <built-in function log10>
log2  :  <built-in function log2>
modf  :  <built-in function modf>
pow  :  <built-in function pow>
radians  :  <built-in function radians>
sin  :  <built-in function sin>
sinh  :  <built-in function sinh>
sqrt  :  <built-in function sqrt>
tan  :  <built-in function tan>
tanh  :  <built-in function tanh>
trunc  :  <built-in function trunc>
pi  :  3.141592653589793
e  :  2.718281828459045
tau  :  6.283185307179586
inf  :  inf
nan  :  nan
....
ZhScheme>(exit)

多数（标准）Scheme里，变量需要先define(定义)，然后set!(赋值)，其实，定义和赋值用一个关键字更为简洁。在ZhScheme里，使用set直接定义并赋值，而且一次能定义并赋值多个变量：
(set (a 12) (b 13) (c "hello"))

ZhScheme的数据类型：

一、基本数据类型(和Python保持一致)：
int float bool string 

二、复合数据类型(和Python保持一致)：
list tuple dict



中缀表达式：

ZhScheme支持符号中缀表达式：j|3.n+3*2-1，符号的运算从左到右。该表达式+在*左边，所以先算+，后算*，这和数学中定义的运算符优先级是不一致的。

注意:

一、表达式中不能有空格，否则会当成几个由空格隔开的表达式，这和其他多数程序设计语言是不一样的。

二、多数Scheme使用-作为变量分隔符，比如你可以定义一个变量is-a-list。因为ZhScheme支持中缀，is-a-list的意义是是3个变量相减。你应当使用_来分割字符串作为变量名:is_a_list。


中缀和前缀的混合使用：j|3.n+(* 3 2)-1


列表定义与元素访问
(set (i (list 12 "hello" 34 True)))
(| i 2)      -- 获得i的第二项 34
i|2         -- 意义同上。

列表元素访问操作符为|，不同于大多程序设计语言，通常使用[]访问数组或者列表，我们做了简化，使用单一操作符|访问列表。用户少敲一个字符，同时解释器的实现也少写一些代码。 


顺序块 (begin (...) (...) (...))
begin -- 关键字，将依次计算各项，返回最后一项；可以嵌套使用。

条件块 (if (1) (2) (3)) 
if -- 关键字，判断1的结果，如果为True，则计算2并返回，否则计算3并返回。
可以嵌套使用。

大多程序设计语言里有return语句，返回函数值，ZhScheme没有return语句，但是可以通过begin和if的返回值来达到和return语句同样的效果。


循环块 -- 可以嵌套使用
while, for, break
for-each


函数定义define与lambda

函数内部可以定义函数，参见newton.s，函数A内定义的函数只能在函数A内使用，A外部的其他函数不能使用。

一个函数可以有不同的参数，分别运算不同的代码。

class

程序设计者可以使用Python的type函数创建一个类，但是多数情况下，你应该使用class直接定义一个类，使用.操作符访问对象的成员。尽量避免使用type函数。


读写文件

读写文件直接使用Python的file对象，以下程序打开test.ss文件，并读取，打印：
(set (f (open "test.ss" "r")))
(print (f.read))


其他常用特性：

一、运行时间 (time (..))  

time --- 关键字，time后只能有一项参数，运行参数项，并打印运行时间。
例如：(time (+ 4 5)) --- 计算”4+5“，并打印运行时间。

你可以用begin将一系列语句包装起来，作为time的参数:
(time (begin (...) (...) (...) (...)))

嵌套使用：
(time (begin (...) (time (...)) (...) (...)))


二、单元测试

单元测试，也就是编写代码测试你的函数。一个非常简单，几乎不会出错的函数，可能不需要单元测试；函数越复杂 --- 输入输出的对应关系越复杂，改动越频繁 --- 越需要单元测试。

编写单元测试代码，可以避免多次重复手工调试，是良好的编程习惯。

(expect (sum 100 0) 5050)

expect关键字运算第二个参数（预期是一个函数调用），如果其结果和第三个参数不符，则打印出错误信息。


三、无用变量的检测警告功能：

new.s文件中定义了一个没有被使用的变量和函数，解释器能够检测到，并给出警告：
(set (abc 123))
(define (efg x) (x))

python ZhScheme.py new.s

E:\Project\ZhScheme>python ZhScheme.py new.s
45150
0
0:00:00.012001
Warn : [ abc ] is not used.
Warn : [ efg ] is not used.


四、递归函数和尾递归

  (define (sum x r)
      (if (eq? x 0)
          (print r)
          (sum (- x 1) (+ x r))
       )
    )
   (sum 150 0)

因为Python不支持尾递归优化。当使用以上求和递归时，超过200层就会出现错误提示:栈不够用。

即使这样，我们还是应该学习什么是尾递归，Python3不支持，不表示永远不支持。




和Lisp/Scheme的一些区别（不完全）：


一、quote用于注释。

取消了Symbol类型，使用python字符串。

二、define和set!

ZhScheme中，define只能定义函数，而变量直接用set定义并赋值，set可以一次定义/赋值多个变量。

三、bool类型

Scheme里bool值为#T和#F,ZheScheme直接使用Python的bool型 -- True和False

四、实现了C风格的while，for循环，循环体中可以使用break跳出循环。

五、取消了cons，实现了car和cdr

Scheme中的cons，作用是构造一个pair，包括左右两个值，在ChezScheme和Racket中，(cons 1 2)的输出是(1 . 2)，用.来区分左右两部分，car取得左值，cdr取得右值，可以对一个list取car和cdr。

六、(env)查看当前的环境变量，你可以在任意位置调用

七、(import test.s)导入并执行test.s文件，可以在任意位置调用。

八、取消了call/cc。笔者认为call/cc相对循环和break语句，更难掌握，因此删掉了call/cc相关代码，增加了break关键字 -- 跳出循环。

九、中缀表达式：

十、同一个函数支持多个参数

